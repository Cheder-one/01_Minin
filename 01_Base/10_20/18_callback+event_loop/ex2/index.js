function runCode() {
    console.log("№1 before promise");

    return new Promise((resolve) => { // Обещает вернуть ответ когда код выполнится
        setTimeout(() => { // setTimeout переходит в буфер ожидания Callback Queue, после setTimeout(console.log("Zero"))
        // Далее код идет выполнять main-задачи, в частности console.log("One"). Как только main-задачи закончились, движок проверяет какие задачи готовы к выполнению (чьи таймеры закончились). 
        // Первым в очереди Callback Queue стоял clg("Zero") и тк время ожидания таймеров у нас одинаково, то он сохраняет свою очередь и идет первым к исполнению. Оболочка таймера раскрывается и clg("Zero") попадает в Стакан Вызовов, где и реализуется, отображая в консоли "Zero"
        // Далее в очереди стоял данный промисовский setTimeout(). Тк его таймер так же равен первому, но пришел он в очередь вторым, то и выполняется он вторым, после "Zero", то есть сейчас. 
        // Оболочка таймера так же раскрывается и первым движок видит console.log("№ Zero Promise"), после чего помещает его в Стакан Вызовов, где тот и исполняется, выводя сообщение "Zero Promise".
            console.log("№4 Zero Promise"); 
            resolve(); // После, в раскрытом таймере видит resolve(). Видит что это Microtask и переводит его в очередь Microtask Queue. Тк микротасков нет, эта задача становится там первой и от туда сразу же перемещается в Стакан Вызовов, где и исполняется с помощью обработчика .then(), выводя в консоль сообщение "Zero Promise Invoked"
        }, 0);
    });
}

setTimeout(() => {
    console.log("№3 Zero");
}, 0);

runCode()
    .then(() => console.log("№5 Zero Promise Invoked"));

console.log("№2 One");
// Zero
